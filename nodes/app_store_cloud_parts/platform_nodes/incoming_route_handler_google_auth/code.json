{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "key": "d6e84b33-256c-438a-9fde-9dac80d54dec",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // handles google auth \n      // - including after redirect! \n      \n      console.log('--google auth handler--');\n      \n      let incomingPath = INPUT.data.req.path;\n      \n      console.log('incomingPath:', incomingPath);\n      \n      const oauth2Client = new universe.google.auth.OAuth2(\n        universe.env.GOOGLE_CLIENT_ID, \n        universe.env.GOOGLE_CLIENT_SECRET,\n        universe.env.GOOGLE_CALLBACK_URL\n      );\n      const scopes = [\n        'profile',\n        'email', // previously: \"https://www.googleapis.com/auth/userinfo.email\"\n      ];\n      \n      \n      let isCallbackRoute = new universe.RouteParser('/auth/google/callback');\n      let isCallbackMatch = isCallbackRoute.match(incomingPath);\n    \n      console.log('isCallbackMatch',isCallbackMatch);\n      \n      let redirectUrl;\n      \n      let session = await universe.httpSession('get');\n        \n      if(!isCallbackMatch){\n        // before callback\n        \n        console.log('Generating URL');\n        \n        redirectUrl = INPUT.data.req.query.onlogin;\n        \n        if(!redirectUrl){\n          await universe.httpResponse('send', 'Invalid redirectUrl supplied for onlogin');\n          return resolve(true);\n        }\n        \n        session.redirectUrl = redirectUrl;\n        \n        \n        const url = oauth2Client.generateAuthUrl({\n          // 'online' (default) or 'offline' (gets refresh_token)\n          // access_type: 'offline',\n          access_type: 'online',\n        \n          // If you only need one scope you can pass it as a string\n          scope: scopes\n        });\n        \n        console.log('Google auth redirect url:', url);\n        await universe.httpResponse('redirect', url);\n        \n        \n      } else {\n        // after redirect\n        \n        console.log('Getting tokens');\n        \n        let accessToken;\n        \n        // This will provide an object with the access_token and refresh_token.\n        // Save these somewhere safe so they can be used at a later time.\n        try {\n          const {tokens} = await oauth2Client.getToken(INPUT.data.req.query.code)\n          \n          // console.log('Google OAuth Tokens:', tokens);\n          \n          oauth2Client.setCredentials(tokens);\n          accessToken = tokens.access_token;\n        }catch(err){\n          // likely trying to redo token, with invalid timestamp/grant \n          console.error('Failed getting tokens', err);\n          await universe.httpResponse('redirect', '/auth/google');\n          return resolve(false);\n        }\n\n        let profileResponse;\n        try {\n          profileResponse = await universe.webrequest.get({\n            url: `https://www.googleapis.com/plus/v1/people/me?access_token=${accessToken}`,\n            json: true\n          });\n        }catch(err){\n          console.error('Failed profileResponse',err);\n          // await universe.httpResponse('send', `Failed Login2`);\n          await universe.httpResponse('redirect', '/auth/google');\n          return resolve(false);\n        }\n        \n        // console.log('profileResponse',profileResponse);\n          \n      \n        // console.log('profileResponse', typeof profileResponse, profileResponse);\n        let loginName = profileResponse.displayName;\n        let loginEmail = profileResponse.emails.find(email=>{return email.type == 'account'});\n        if(loginEmail){\n          loginEmail = loginEmail.value;\n        }\n        \n        console.log('loginName:', loginName);\n        console.log('loginEmail:', loginEmail);\n        \n        // Update/Create local internal_user \n        let profileNode;\n        let profileNodes = await universe.searchMemory({\n          filter: {\n            sqlFilter: {\n              // nodeId: null // OLD: root-level\n              type: 'internal_user:0.0.1:local:98h32',\n              data: {\n                uuid: loginEmail\n              }\n            },\n          }\n        });\n        if(profileNodes.length){\n          profileNode = profileNodes[0];\n        }\n        \n        if(profileNode){\n          // update \n          console.log('Updating internal_user for auth');\n            \n          profileNode.data.passphrase = accessToken;\n          profileNode.data.lastLogin = Date.now();\n          \n          let updatedNode = await universe.updateNode(profileNode);\n          \n        } else {\n          // create new \n          console.log('Creating new internal_user for auth');\n          let newNode = {\n            type: 'internal_user:0.0.1:local:98h32',\n            data: {\n              roles: [], // no default roles? \n              uuid: loginEmail, // unique identifier\n              passphrase: accessToken,\n              lastLogin: Date.now()\n            }\n          }\n          \n          let savedNode = await universe.newNode(newNode);\n          \n        }\n        \n        // build redirectUrl \n        // - uses passphrase/accessToken as hash (removed immediately?) \n        //   - TODO: more secure \n        \n        redirectUrl = session.redirectUrl;\n        redirectUrl = redirectUrl + '#token=' + accessToken;\n        \n        // redirect back to session's redirectUrl \n        if(session.redirectUrl){\n          await universe.httpResponse('redirect', redirectUrl);\n        } else {\n          await universe.httpResponse('send', 'Invalid session redirectUrl for response');\n        }\n        \n      }\n      \n      \n      return resolve(true); \n      \n      // await universe.httpResponse('send', `Welcome to google auth page`);\n            \n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  }
}